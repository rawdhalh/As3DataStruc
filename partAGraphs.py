# -*- coding: utf-8 -*-
"""part A.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T6JvI83MA3caEynaZhODXEnvJSDbEsI5
"""

import heapq  # Importing the heapq module for the MaxHeap data structure

class SocialMediaPosts:
    def __init__(self):
        self.posts = {}  # Initialize an empty dictionary to store social media posts

    def add_post(self, datetime, post, person):
        # Add a post to the social media posts dictionary
        self.posts[datetime] = (post, person)

    def find_post_by_datetime(self, datetime):
        # Find a post in the social media posts dictionary by its unique datetime
        return self.posts.get(datetime, None)

class TreeNode:
    def __init__(self, key, value):
        self.key = key
        self.values = [value]
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None  # Initialize an empty root node for the Binary Search Tree

    def insert(self, key, value):
        # Insert a key-value pair into the Binary Search Tree
        self.root = self._insert(self.root, key, value)

    def _insert(self, node, key, value):
        # Private method to recursively insert a key-value pair into the Binary Search Tree
        if node is None:
            return TreeNode(key, value)
        if key < node.key:
            node.left = self._insert(node.left, key, value)
        elif key > node.key:
            node.right = self._insert(node.right, key, value)
        else:
            node.values.append(value)
        return node

    def search_range(self, start_datetime, end_datetime):
        # Search for key-value pairs within a specific time range in the Binary Search Tree
        results = []  # Initialize an empty list to store search results
        self._search_range(self.root, start_datetime, end_datetime, results)
        return results

    def _search_range(self, node, start_datetime, end_datetime, results):
        # Private method to recursively search for key-value pairs within a time range
        if node is None:
            return
        if start_datetime <= node.key <= end_datetime:
            for value in node.values:
                results.append((node.key, value))
        if start_datetime < node.key:
            self._search_range(node.left, start_datetime, end_datetime, results)
        if end_datetime > node.key:
            self._search_range(node.right, start_datetime, end_datetime, results)

class MaxHeap:
    def __init__(self):
        self.heap = []  # Initialize an empty list to store elements in the MaxHeap

    def add_post(self, views, post, person):
        # Add a post to the MaxHeap with its number of views as the priority
        heapq.heappush(self.heap, (-views, (post, person)))

    def get_most_viewed_post(self):
        # Get the post with the most views from the top of the MaxHeap
        if self.heap:
            return self.heap[0][1]
        else:
            return None

def main():
    social_media = SocialMediaPosts()  # Create an instance of the SocialMediaPosts class
    bst = BST()  # Create an instance of the Binary Search Tree class
    max_heap = MaxHeap()  # Create an instance of the MaxHeap class

    # Test cases for social media posts
    social_media.add_post("2024-04-26 10:00:00", "Hello", "@Salama123")
    social_media.add_post("2023-03-12 12:30:00", "At the beach!", "@Khaled234")
    social_media.add_post("2024-04-26 12:00:00", "today is a good day.", "@Reem_2002")
    social_media.add_post("2024-02-20 9:30:00", "Hi", "@Salem89")
    social_media.add_post("2024-04-26 7:29:21", "Hello", "@Salam123")
    social_media.add_post("2023-12-31 10:00:00", "Happy New Year", "@Shamsa_221")
    social_media.add_post("2023-01-26 10:00:00", "its so sunny", "@Zayed234")

    # Populate the Binary Search Tree and the MaxHeap with test case data
    for datetime in social_media.posts.keys():
        bst.insert(datetime, social_media.posts[datetime])
        views = len(social_media.posts[datetime][0])  # Number of characters in post is used as views for simplicity
        max_heap.add_post(views, social_media.posts[datetime][0], social_media.posts[datetime][1])

    # Creating a Menu foe the user to select their choice
    while True:
        print("\nMenu: Please select from 1-4 ")
        print("1. Find a post by its unique datetime value")
        print("2. Find posts in a specific time range")
        print("3. Prioritize social media posts by number of views")
        print("4. Exit")

        choice = input("Enter your choice: ")

        if choice == '1':
            datetime = input("Enter datetime to find post (YYYY-MM-DD HH:MM:SS): ")
            post_info = social_media.find_post_by_datetime(datetime)
            if post_info:
                print("Found post:", post_info)
            else:
                print("No post found for given datetime.")
        elif choice == '2':
            start_datetime = input("Enter start datetime (YYYY-MM-DD HH:MM:SS): ")
            end_datetime = input("Enter end datetime (YYYY-MM-DD HH:MM:SS): ")
            posts_in_range = bst.search_range(start_datetime, end_datetime)
            print("Posts between {} and {}: {}".format(start_datetime, end_datetime, posts_in_range))
        elif choice == '3':
            most_viewed_post = max_heap.get_most_viewed_post()
            if most_viewed_post:
                print("Most viewed post:", most_viewed_post)
            else:
                print("No posts available.")
        elif choice == '4':
            print("Exiting...")
            break
        else:
            print("Invalid choice. Please enter a number between 1 and 4.")


if __name__ == "__main__":
    main()

pip install matplotlib

import timeit
import matplotlib.pyplot as plt

# Function to measure the time taken for adding posts
def measure_add_post_time(social_media, datetime, post, person):
    start_time = timeit.default_timer()
    social_media.add_post(datetime, post, person)
    end_time = timeit.default_timer()
    return end_time - start_time

# Create an instance of SocialMediaPosts
social_media = SocialMediaPosts()

# Sample sizes for the graph
sample_sizes = [10, 100, 1000, 10000]
# Measure time for adding posts to SocialMediaPosts
social_media_times = [measure_add_post_time(social_media, f"2024-04-26 {i}:00:00", f"Post {i}", f"User {i}") for i in range(len(sample_sizes))]

# Plotting the graph
plt.figure(figsize=(10, 6))
plt.plot(sample_sizes, social_media_times, marker='o')
plt.title("Time Complexity for Adding Posts to SocialMediaPosts")
plt.xlabel("Number of Posts")
plt.ylabel("Time (seconds)")
plt.xscale("log")
plt.yscale("log")
plt.grid(True)
plt.show()

import timeit

class TreeNode:
    def __init__(self, key, value):
        self.key = key
        self.values = [value]
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None  # Initialize an empty root node for the Binary Search Tree

    def insert(self, key, value):
        # Insert a key-value pair into the Binary Search Tree
        self.root = self._insert(self.root, key, value)

    def _insert(self, node, key, value):
        # Private method to recursively insert a key-value pair into the Binary Search Tree
        if node is None:
            return TreeNode(key, value)
        if key < node.key:
            node.left = self._insert(node.left, key, value)
        elif key > node.key:
            node.right = self._insert(node.right, key, value)
        else:
            node.values.append(value)
        return node

    def search(self, key):
        # Search for a key in the BST
        return self._search(self.root, key)

    def _search(self, node, key):
        if node is None:
            return None
        elif key == node.key:
            return node.values
        elif key < node.key:
            return self._search(node.left, key)
        else:
            return self._search(node.right, key)

# Function to measure the time taken for searching in a BST
def measure_search_time(bst, key):
    start_time = timeit.default_timer()
    bst.search(key)
    end_time = timeit.default_timer()
    return end_time - start_time

# Create an instance of BST and populate it
bst = BST()
for i in range(10000):
    bst.insert(f"2024-04-26 {i}:00:00", f"Post {i}")

# Sample sizes for the graph
sample_sizes = [10, 100, 1000, 10000]
bst_search_times = []

# Measuring search times for the last element inserted (worst case)
for size in sample_sizes:
    time_taken = measure_search_time(bst, f"2024-04-26 {size-1}:00:00")
    bst_search_times.append(time_taken)

# Plotting the graph
plt.figure(figsize=(10, 6))
plt.plot(sample_sizes, bst_search_times, marker='o')
plt.title("Time Complexity for Searching in a BST")
plt.xlabel("Number of Elements")
plt.ylabel("Time (seconds)")
plt.xscale("log")
plt.yscale("log")
plt.grid(True)
plt.show()

import heapq
import timeit

class MaxHeap:
    def __init__(self):
        self.heap = []  # Initialize an empty list to store elements in the MaxHeap

    def add_post(self, views, post):
        # Add a post to the MaxHeap with its number of views as the priority
        heapq.heappush(self.heap, (-views, post))

# Function to measure the time taken for adding posts to a MaxHeap
def measure_add_post_to_heap_time(max_heap, views, post):
    start_time = timeit.default_timer()
    max_heap.add_post(views, post)
    end_time = timeit.default_timer()
    return end_time - start_time

# Create an instance of MaxHeap
max_heap = MaxHeap()

# Sample sizes for the graph
sample_sizes = [10, 100, 1000, 10000]
heap_addition_times = []

# Measure time for adding posts to MaxHeap
for i in range(len(sample_sizes)):
    views = len(f"Post {sample_sizes[i]}")
    time_taken = measure_add_post_to_heap_time(max_heap, views, f"Post {sample_sizes[i]}")
    heap_addition_times.append(time_taken)

# Plotting the graph
plt.figure(figsize=(10, 6))
plt.plot(sample_sizes, heap_addition_times, marker='o')
plt.title("Time Complexity for Adding Posts to a MaxHeap")
plt.xlabel("Number of Posts")
plt.ylabel("Time (seconds)")
plt.xscale("log")
plt.yscale("log")
plt.grid(True)
plt.show()

import timeit
import matplotlib.pyplot as plt

# Reuse the previously defined classes SocialMediaPosts, BST, and MaxHeap

# Function to measure the total time taken for all operations per post
def measure_all_operations_time(social_media, bst, max_heap, datetime, post, person):
    start_time = timeit.default_timer()
    # Add post to SocialMediaPosts
    social_media.add_post(datetime, post, person)
    # Insert post into BST
    bst.insert(datetime, (post, person))
    # Add post to MaxHeap with view count as priority (simplified as post length)
    views = len(post)
    max_heap.add_post(views, (post, person))
    end_time = timeit.default_timer()
    return end_time - start_time

# Instances of the data structures
social_media = SocialMediaPosts()
bst = BST()
max_heap = MaxHeap()

# Sample sizes for the graph
sample_sizes = [10, 100, 1000, 10000]
total_times = []

# Conducting the measurements
for i in range(len(sample_sizes)):
    datetime = f"2024-04-26 {i}:00:00"
    post = f"Post {i}"
    person = f"User {i}"
    time_taken = measure_all_operations_time(social_media, bst, max_heap, datetime, post, person)
    total_times.append(time_taken)

# Plotting the graph
plt.figure(figsize=(10, 6))
plt.plot(sample_sizes, total_times, marker='o')
plt.title("Overall Time Complexity for Combined Operations")
plt.xlabel("Number of Posts")
plt.ylabel("Time (seconds)")
plt.xscale("log")
plt.yscale("log")
plt.grid(True)
plt.show()