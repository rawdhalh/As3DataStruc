# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16hWQXZa2w8Di8R3cglmYBEqgif_1Xhqq
"""

import networkx as nx
import matplotlib.pyplot as plt
import heapq

class Graph:
   def __init__(self):
       # Initialize an empty dictionary to store vertices and their connections
       self.vertices = {}
       self.homes = []

   def add_vertex(self, vertex_id):
       # Add a new vertex to the graph if it doesn't already exist
       if vertex_id not in self.vertices:
           self.vertices[vertex_id] = {}

   def add_edge(self, start, end, road_id, road_name, length):
       # Add a new edge (road) between two vertices (intersections)
       # If the vertices don't exist, add them to the graph
       if start not in self.vertices:
           self.add_vertex(start)
       if end not in self.vertices:
           self.add_vertex(end)
       # Store information about the edge including road ID, name, and length
       self.vertices[start][end] = {'road_id': road_id, 'road_name': road_name, 'length': length}
       self.vertices[end][start] = {'road_id': road_id, 'road_name': road_name, 'length': length}

   def add_home(self, home_id, intersection_id, distance):
       self.add_edge(home_id, intersection_id, 10, 'home road', distance)
       self.homes.append({"home_id": home_id, "intersection_id": intersection_id, "distance": distance})

   def print_all_homes(self):
       # Print all homes in the graph
       print("HOMES:")
       for home in self.homes:
           print(f"Home ID: {home['home_id']}, Intersection: {home['intersection_id']}, Distance: {home['distance']}")

   def print_homes(self):
       print("Houses:")
       for home in self.homes:
           print(f"{home['home_id']}")

   def print_all_intersections(self):
       # Print all intersections in the graph
       print("packages intersection:")
       [print(f"{node}") for node in self.vertices if 'H' not in str(node)]

   def get_neighbors(self, vertex_id):
       # Retrieve neighbors (adjacent vertices) of a given vertex
       return self.vertices[vertex_id]

   def shortest_distance(self, start, end):
       # Use Dijkstra's algorithm to find the shortest distance from 'start' to 'end' in the road network
       distances = {vertex: float('inf') for vertex in self.vertices}
       distances[start] = 0
       queue = [(0, start)]  # Initialize a priority queue with starting vertex and distance 0

       while queue:
           current_distance, current = heapq.heappop(queue)  # Dequeue the vertex with the minimum distance
           if current == end:
               return current_distance
           if current_distance > distances[current]:
               continue
           for neighbor, edge in self.get_neighbors(current).items():
               distance = current_distance + edge['length']
               if distance < distances[neighbor]:
                   distances[neighbor] = distance
                   heapq.heappush(queue, (distance, neighbor))

# Function to convert custom Graph to a networkx graph
def convert_to_networkx(custom_graph):
   G = nx.Graph()  # Create an undirected graph (or nx.DiGraph for directed)
   for start, neighbors in custom_graph.vertices.items():
       for end, edge_info in neighbors.items():
           G.add_edge(
               start,
               end,
               road_id=edge_info['road_id'],
               road_name=edge_info['road_name'],
               length=edge_info['length']
           )
   return G

def view_road_network(custom_graph):
   G = convert_to_networkx(custom_graph)

   # Define a layout for the graph
   pos = nx.spring_layout(G)

   intersection_nodes = [node for node, a in G.adj.items() if 'H' not in str(node)]
   home_nodes = [node for node, a in G.adj.items() if 'H' in str(node)]

   # Draw the graph
   nx.draw(G, pos, with_labels=True, nodelist=intersection_nodes, node_size=1000, node_color="skyblue", font_weight="bold")
   nx.draw(G, pos, with_labels=True, nodelist=home_nodes, node_size=1000, node_color="orange", font_weight="bold")
   # Add edge labels to show road names or lengths
   edge_labels = nx.get_edge_attributes(G, 'length')  # Get the edge labels (length)
   nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

   # Display the graph in the Jupyter notebook
   plt.title("Road Graph")
   plt.show()

graph = Graph()
graph.add_edge('A', 'B', 1, 'Main St', 6)
graph.add_edge('B', 'C', 2, 'Broadway', 8)
graph.add_edge('C', 'D', 3, 'Elm St', 2)
graph.add_edge('D', 'E', 4, 'Oak St', 1)

graph.add_edge('A', 'C', 5, 'First Ave', 7)
graph.add_edge('B', 'D', 6, 'Second Ave', 3)

graph.add_edge('C', 'E', 7, 'Third Ave', 2)
graph.add_edge('D', 'F', 8, 'Fourth Ave', 10)

graph.add_home("H1", 'B', 3)
graph.add_home("H2", 'E', 5)
graph.add_home("H3", 'D', 9)
graph.add_home("H4", 'C', 7)

while True:
   print("MENU:")
   print("1. get the shortest between a source and destination intersection")
   print("2. View the road network")
   print("3. View the list of homes")
   print("4. Exit")

   choice = input("Enter your choice (1-4): ")

   if choice == "1":
       # Compute shortest path
       graph.print_all_intersections()
       source_intersection = input("Enter the source intersection: ")
       graph.print_homes()
       destination_intersection = input("Enter the destination intersection: ")
       shortest_path = graph.shortest_distance(source_intersection, destination_intersection)
       print("Shortest path from intersection", source_intersection, "to", destination_intersection, ":", shortest_path)
   elif choice == "2":
       view_road_network(graph)
   elif choice == "3":
       print("List of Homes:")
       graph.print_all_homes()
   elif choice == "4":
       print("Exiting...")
       break
   else:
       print("Invalid choice. Please select a valid option (1-4).")